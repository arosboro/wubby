// The 'wubby' program.
program wubby.aleo {

    struct Ascii32 {
        a0: u8,
        a1: u8,
        a2: u8,
        a3: u8,
        a4: u8,
        a5: u8,
        a6: u8,
        a7: u8,
        a8: u8,
        a9: u8,
        a10: u8,
        a11: u8,
        a12: u8,
        a13: u8,
        a14: u8,
        a15: u8,
        a16: u8,
        a17: u8,
        a18: u8,
        a19: u8,
        a20: u8,
        a21: u8,
        a22: u8,
        a23: u8,
        a24: u8,
        a25: u8,
        a26: u8,
        a27: u8,
        a28: u8,
        a29: u8,
        a30: u8,
        a31: u8,
    }

    struct Ascii255 {
        a0: u8,
        a1: u8,
        a2: u8,
        a3: u8,
        a4: u8,
        a5: u8,
        a6: u8,
        a7: u8,
        a8: u8,
        a9: u8,
        a10: u8,
        a11: u8,
        a12: u8,
        a13: u8,
        a14: u8,
        a15: u8,
        a16: u8,
        a17: u8,
        a18: u8,
        a19: u8,
        a20: u8,
        a21: u8,
        a22: u8,
        a23: u8,
        a24: u8,
        a25: u8,
        a26: u8,
        a27: u8,
        a28: u8,
        a29: u8,
        a30: u8,
        a31: u8,
        a32: u8,
        a33: u8,
        a34: u8,
        a35: u8,
        a36: u8,
        a37: u8,
        a38: u8,
        a39: u8,
        a40: u8,
        a41: u8,
        a42: u8,
        a43: u8,
        a44: u8,
        a45: u8,
        a46: u8,
        a47: u8,
        a48: u8,
        a49: u8,
        a50: u8,
        a51: u8,
        a52: u8,
        a53: u8,
        a54: u8,
        a55: u8,
        a56: u8,
        a57: u8,
        a58: u8,
        a59: u8,
        a60: u8,
        a61: u8,
        a62: u8,
        a63: u8,
        a64: u8,
        a65: u8,
        a66: u8,
        a67: u8,
        a68: u8,
        a69: u8,
        a70: u8,
        a71: u8,
        a72: u8,
        a73: u8,
        a74: u8,
        a75: u8,
        a76: u8,
        a77: u8,
        a78: u8,
        a79: u8,
        a80: u8,
        a81: u8,
        a82: u8,
        a83: u8,
        a84: u8,
        a85: u8,
        a86: u8,
        a87: u8,
        a88: u8,
        a89: u8,
        a90: u8,
        a91: u8,
        a92: u8,
        a93: u8,
        a94: u8,
        a95: u8,
        a96: u8,
        a97: u8,
        a98: u8,
        a99: u8,
        a100: u8,
        a101: u8,
        a102: u8,
        a103: u8,
        a104: u8,
        a105: u8,
        a106: u8,
        a107: u8,
        a108: u8,
        a109: u8,
        a110: u8,
        a111: u8,
        a112: u8,
        a113: u8,
        a114: u8,
        a115: u8,
        a116: u8,
        a117: u8,
        a118: u8,
        a119: u8,
        a120: u8,
        a121: u8,
        a122: u8,
        a123: u8,
        a124: u8,
        a125: u8,
        a126: u8,
        a127: u8,
        a128: u8,
        a129: u8,
        a130: u8,
        a131: u8,
        a132: u8,
        a133: u8,
        a134: u8,
        a135: u8,
        a136: u8,
        a137: u8,
        a138: u8,
        a139: u8,
        a140: u8,
        a141: u8,
        a142: u8,
        a143: u8,
        a144: u8,
        a145: u8,
        a146: u8,
        a147: u8,
        a148: u8,
        a149: u8,
        a150: u8,
        a151: u8,
        a152: u8,
        a153: u8,
        a154: u8,
        a155: u8,
        a156: u8,
        a157: u8,
        a158: u8,
        a159: u8,
        a160: u8,
        a161: u8,
        a162: u8,
        a163: u8,
        a164: u8,
        a165: u8,
        a166: u8,
        a167: u8,
        a168: u8,
        a169: u8,
        a170: u8,
        a171: u8,
        a172: u8,
        a173: u8,
        a174: u8,
        a175: u8,
        a176: u8,
        a177: u8,
        a178: u8,
        a179: u8,
        a180: u8,
        a181: u8,
        a182: u8,
        a183: u8,
        a184: u8,
        a185: u8,
        a186: u8,
        a187: u8,
        a188: u8,
        a189: u8,
        a190: u8,
        a191: u8,
        a192: u8,
        a193: u8,
        a194: u8,
        a195: u8,
        a196: u8,
        a197: u8,
        a198: u8,
        a199: u8,
        a200: u8,
        a201: u8,
        a202: u8,
        a203: u8,
        a204: u8,
        a205: u8,
        a206: u8,
        a207: u8,
        a208: u8,
        a209: u8,
        a210: u8,
        a211: u8,
        a212: u8,
        a213: u8,
        a214: u8,
        a215: u8,
        a216: u8,
        a217: u8,
        a218: u8,
        a219: u8,
        a220: u8,
        a221: u8,
        a222: u8,
        a223: u8,
        a224: u8,
        a225: u8,
        a226: u8,
        a227: u8,
        a228: u8,
        a229: u8,
        a230: u8,
        a231: u8,
        a232: u8,
        a233: u8,
        a234: u8,
        a235: u8,
        a236: u8,
        a237: u8,
        a238: u8,
        a239: u8,
        a240: u8,
        a241: u8,
        a242: u8,
        a243: u8,
        a244: u8,
        a245: u8,
        a246: u8,
        a247: u8,
        a248: u8,
        a249: u8,
        a250: u8,
        a251: u8,
        a252: u8,
        a253: u8,
        a254: u8,
    }

    struct DomainInstance {
        name: Ascii32,
    }

    struct NamespaceDefinition {
        name: Ascii32,
        uri: Ascii32,
    }

    struct NamespaceInstance {
        namespace: NamespaceDefinition,
    }

    struct ElementDefinition {
        keyword: Ascii32,
    }

    struct AttributeDefinition {
        keyword: Ascii32,
        is_global: bool,
    }

    struct ElementInstance {
        element: ElementDefinition,
        is_root: bool,
    }

    struct AttributeInstance {
        attribute: AttributeDefinition,
        state: Ascii32,
    }

    record Domain {
        owner: address,
        gates: u64,
        public_registry: bool,
        collection_id: u128,
        domain: DomainInstance,
        namespace: NamespaceInstance,
        element: ElementInstance,
        attribute: AttributeInstance,
        parent_element_id: u128,
        element_id: u128,
        attribute_Id: u128,
    }

    function null_ascii32() -> Ascii32 {
        return Ascii32 {
            a0: 0u8,
            a1: 0u8,
            a2: 0u8,
            a3: 0u8,
            a4: 0u8,
            a5: 0u8,
            a6: 0u8,
            a7: 0u8,
            a8: 0u8,
            a9: 0u8,
            a10: 0u8,
            a11: 0u8,
            a12: 0u8,
            a13: 0u8,
            a14: 0u8,
            a15: 0u8,
            a16: 0u8,
            a17: 0u8,
            a18: 0u8,
            a19: 0u8,
            a20: 0u8,
            a21: 0u8,
            a22: 0u8,
            a23: 0u8,
            a24: 0u8,
            a25: 0u8,
            a26: 0u8,
            a27: 0u8,
            a28: 0u8,
            a29: 0u8,
            a30: 0u8,
            a31: 0u8,
        };
    }

    mapping domains: address => Domain;
    mapping collections: address => u128;
    mapping namespaces: address => u8;
    mapping elements: address => u8;
    mapping attributes: address => u8;

    transition register_namespace(public name: Ascii32, public uri: Ascii32) -> NamespaceDTD {
        return NamespaceDTD {
            owner: self.caller,
            gates: 0u64,
            data: NamespaceDefinition {
                name,
                uri,
            }
        } then finalize(self.caller);
    }

    finalize register_namespace(caller: address) {
        increment(namespaces_count, caller, 1u8);
    }

    transition main(public: public_registry: bool, public: domain_name, public namespace_name: Ascii32, public namespace_uri, public element_keyword: Ascii32, public element_is_root: bool, public attribute_keyword: Ascii32, public, public attribute_is_global: bool, public attribute_state: Ascii32) -> ElementDTD {
        let domain: DomainInstance = DomainInstance {
            name: domain_name,
        };
        let namespace: NamespaceInstance = NamespaceInstance {
            name: namespace_name,
            uri: namespace_uri,
        };
        let element: ElementInstance = ElementInstance {
            element: ElementDefinition {
                keyword: element_keyword,
            },
            is_root: element_is_root,
        };
        let attribute: AttributeInstance = AttributeInstance {
            attribute: AttributeDefinition {
                attribute_keyword: empty_ascii,
                is_global: false,
            },
            state: attribute_state,
        };
        return Domain {
            owner: address,
            gates: u64,
            public_registry: bool,
            collection_id: u128,
            domain,
            namespace,
            element,
            attribute,
            parent_element_id: u128,
            element_id: u128,
            attribute_Id: u128,
        } then finalize(self.caller);

    finalize main(caller: address) {
        increment(domains_count, caller, 1u8);
        increment(namespaces_count, caller, 1u8);
        increment(elements_count, caller, 1u8);
        increment(attributes_count, caller, 1u8);'
    }
}